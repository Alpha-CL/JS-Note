# Modular-Introduction

#### Development Of Node

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * stage - 1
 * 
 * 
 */


在 JavaScript 语言刚刚诞生的时候，仅用于实现页面中一些小效果，当时一个页面所用到 JS 可能只有几百行

在这种情况下，语言本身所存在的一些缺陷往往被大家有意的忽略，因程序的规模太小，仅需开发人员规避即可

在这个阶段，并不存在专业的前端工程师，因前端需要做的事情并不多，则这部分工作往往由后端工程师顺带完成

第一阶段发生的大事情:

1) 1996 年，NetScape JavaScript 语言提交给欧洲的一个标准制定阻止 ECMA( 欧洲计算机制造商协会 ) 

2) 1998 年，NetScape 在与微软浏览器 IE 的竞争中失利，宣布破产



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * stage - 2
 * 
 * 
 */


ajax 的出现，逐渐改变了 JavaScript 在浏览器环境中所扮演的角色

目前，JS 不仅可以实现小的效果，还可以和服务器之间进行交互，以更好的体验来改变数据

JS 代码的数量开始逐渐增长，从最初的 几百行，到后来的几万行，前端程序逐渐变得复杂

后端开发者压力逐渐增加，致使一些公司开始招募专业的前端开发者

但此时，前端开发者的待遇远不及后端开发者，因前端开发者承担的开发任务相对于后端开发者来说，仍比较简单


因以下问题还未解决，所以限制了前端的发展

1) 浏览器解释执行 JS 速度太慢

2) 用户的电脑配置不足

3) 更多的 JS 代码带来了 '全局污染'，依赖关系混乱等


第二阶段的发生的大事件

1) IE 浏览器制霸市场后，几乎不更新

2) ES4.0 流产，导致 JS 语言 10 年间几乎毫无变化

3) 2008 年 ES5 发布，仅解决部分 JS API 的不足


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * stage - 3
 * 
 * 
 */


2008 年，谷歌推出 V8 引擎，将 JS 的执行速度腿上了一个新的台阶，甚至可以和后端语言媲美

用户电脑配置开始飞跃的提升，仅剩 全局变量污染 和 依赖混乱 的问题

2008 年 Ryan Dahl 正在为一件事情焦头烂额，它需要在服务端手写一个高性能的 web 服务，
该服务对于性能要求之高，以至于目前市面上已有的 web 服务产品都不能满足其需求

经过分析，他确定，如果要实现高性能，那么必须要尽少的减少线程，而减少线程，并避免不了要实用异步的处理方案

开始，他打算用 C/C++ 语言来编写，这个过程很痛苦

就在此时，谷歌 V8 引擎发布，他突然发现 JS 不就是实现 web 服务较好的选择，JS 天生就是 单线程，并且基于异步，又有了 V8 引擎的支持，
他的执行速度足以支撑一个服务器，谷歌的 V8 引擎也会不断的免费优化

于是，他基于开源的 V8 引擎，对源码做了一些修改，很快就完成了该项目

2009 年，Ryan 退出了该 web 服务项目，命名为 node.js

从此，JS 进入后端开发环境，不再局限于 Web 开发环境，ES 语言是一门真正的语言，他的宿主环境，决定了他的功能



node.js 的诞生，便把 JS 中最后的问题放到了台前 全局变量污染 和 依赖混乱，直到 node.js 是服务端，若不解决这个问题，
分模块开发就无法实现，而模块化开发是后端程序必不可少的内容

经过社区激烈的讨论，最终形成了一个模块化方案 CommonJS, 该方案解决了 全局变量污染 和 依赖混乱，该方案一出，即被 node.js 支持

于是 node.js 成为了为 JS 语言实现模块化开发的平台


第三阶段发生的大事件:

1) 2008 年，谷歌推出 V8 引擎

2) IE 市场逐步被 firefox 和 chrome 蚕食

3) 2009 年，node.js 发布，并附带 commonjs 模块化开发标准


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * stage - 4
 * 
 * 
 */
 
CommonJS 的出现打开了前端开发者的思路

既然后端可以使用模块化开发 JS，前端为何不可呢？

于是，有人开始把 CommonJS 运用到浏览器环境中，但实现较为困难，最终重新定义了一个模块化标准

很快 AMD 规范出现，它解决了 全局变量污染 和 依赖混乱，ECMA 后续对其又进行了改进

2015 年，ES6 发布，它提出了官方的模块化解决方案: ES6 模块化

从此以后，模块化开发成为了 JS 本身特有的性质，成为了可以编写大型应用的正是语言

于此同时，很多开发者和技术厂商发现了JS的无穷潜力

* 既然JS可以编写大型应用，那么自然需要像其他语言那样的开发框架

    - Angular，React，Vue 等前端开发框架出现
    
    - Express，Koa 等互殴段开发框架出现
    
    - 各种后端数据库驱动出现


* 要开发大型应用，自然少不了各种实用的第三方库的支持

    - npm 包管理器出现，使用第三方库变得及其方便
 
    - webpack 等构建工具出现，专门用于打包和部署

* 既然 JS 可以放到服务器环境，为什么不能放在其他终端环境中呢

    - Electron 发布，可以使用 JS 语言开发桌面应用
    
    - RN 和 VueX 等技术发布，可以使用 JS 语言编写移动端应用程序
    
    - 各种小程序出现，可以使用 JS 编写依附于其他应用的小程序
    
    - 目前还有很多厂商致力于将 JS 应用到其他的额终端设备，最终形成大前端生态环境



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### NodeJS

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * node.js
 * 
 * 
 */


node.js 遵循 ECMASCript 标准，但由于脱离了浏览器环境，因此

1) 可以在 node.js 中使用 ECMASCript 标准的任何语法或API，如: 循环，判断，数组，对象等

2) 不能在 node.js 中使用浏览器的 web api, 例如: dom对象，window对象，document对象等

由于大部分开发者是从浏览器端开发转向 node.js 开发的，为了降低开发者的额学习成本，node.js 中提供了一些和浏览器 web api 同样的对象和函数

如: console, setTiemeout, setInterval 等


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### CommonJS

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


在 node.js 中，由于有且只有一个入口文件( 启动文件 )，而开发一个应用肯定会涉及到多个文件配合

因此，node.js 对模块化的需求必浏览器要大的多

由于 node.js 刚发布时，前端没有统一的官方模块化规范，因此起初选择使用 社区提供的 CommonJS 作为模块化规范


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 模块化导出
 * 
 * 
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 什么是模块
 * 
 * 
 */

模块就是一个 JS 文件，它实现了一部分功能，并隐藏自己的内部实现，同时提供部分接口供其他模块使用

模块化有两个核心要素 '暴露': 供其他模块使用的接口 和 '隐藏': 自身内部的实现原理

任何一个正常的模块化标准，都具备默认隐藏模块中所有的实现，而通过语法或api来调用暴露的接口


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 暴露接口的过程称为: 模块的导出
 * 
 * 
 */


                + ----------- util.js ------------- +
                |                                   |
                |                                   |
                |           + ---------------- +    |
                |           |                  |    |
                |           |                  |    |
                            |                  |    |
         functio-sort       |                  |    |
                            |                  |    |
                |           |  Hide internal   |    |
                |           |                  |    |
                            |  implementation  |    |
         obj-helper         |                  |    |
                            |                  |    |
                |           |                  |    |
                |           |                  |    |
                            |                  |    |
         string-name        |                  |    |
                            |                  |    |
                |           |                  |    |
                |           + ---------------- +    |
                |                                   |
                |                                   |
                + --------------------------------- +


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * CommonJS Specification
 * 
 * 
 * 
 */

1) 若 JS 文件中存在 exports 或 require，则该 JS 文件是一个模块

2) 模块内的所有代码均为隐藏代码，包括 全局变量，全局函数，即对全局变量造成污染的任何内容

3) 若一个模块需要暴露一些 API 提供给 外部使用，必须使用 exports 导出，exports 是一个空对象，可以为该对象添加任何需要导出的内容

4) 若一个莫哦快需要倒入其他模块，必须使用 requiree 导入，require 是一个函数，参数为导入模块的路径


//-------------------------------------------------------------------------------------------------------------------//

 
/**
 * exports.key = value: any;
 * 
 * 
 */

exports.key = prop/methods;                 // 导出单个属性或方法

exports.key = {                             // 导出多个属性或方法

    prop,
    method
};

exports.key = {                             // 导出多个属性或方法

    prop,
    method
};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * require(url: string): ;
 * 
 * 
 * @url: 必须以 './ or ../' 开头，否则有歧义并无法执行
 */

const result = require('./demo.js');


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * invoking ( prop / method ) of required
 * 
 * 
 */

const result = require('./demo.js');


result.propName;                    // 获取导出中指定属性的值

result.method();                    // 执行导出中指定的方法


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### CommonJS Implementation Principle

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * commonjs 执行原理
 * 
 * 
 */

1) 为了保证高效的执行，仅加载必要的模块，node.js 只有执行到 require 函数时，才会加载并执行模块


2) 为了隐藏模块中的代码，node.js 执行模块时，会将模块中的所有代码放置到一个函数中执行，以保证不污染全局变量

(function(module){ // Module Code }());


3) 为了抱着鞥顺利的导出模块内容，node.js 做了以下处理

    - 在模块开始执行之前，初始化一个值 module.exports = {}
    
    - module.exports 即为模块的导出值

    - 为了方便开发者便捷的导出，node.js 在初始化完 module.exports 后，又声明了一个变量 exports = module.exports;


4) 为了避免反复加载同一模块，node.js 默认开启模块缓存，模块会在第一次加载时缓存返回结果，后续再次调用会直接导出的缓存中的返回结果


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 模拟导出运行原理
 * 
 */

(function(module){

    module.exports = {};
    
    let exports = module.exports;                   // 为了方便开发者便捷导出
    
    
    exports.prop = val;
    
    exports.methods = function() {
    
    };
    
    ...
    
    
    module.exports = val;                           // 更加灵活，可直接赋值

    module.exports.prop = val;
    
    module.exports.methods = function() {
    
    };
    
    ...


    retrun module.exports;

}());


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


console.log(module.exports === exports);            // true

module.exports = {                                  // 修改 module.exports 为新的对象地址

    getNumber() {

        return count++;
    },

    abc: 123
};


/**
 * 因在上面已经修改 module.exports 中存储的地址
 * 内部后续声明的 exports 无法指向已执行代码时改变的地址
 *
 * 因最终返回 module.exports 地址已更改，所以无法返回 exports 所对应原 module.exports 地址中的属性和方法
 */

exports.bcd = 234;                                  // undefined

console.log(module.exports === exports);            // false


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 建议使用 module.exports                  // 较为灵活
 * 
 * 
 * exports 默认返回对象，并且无法重新赋值
 */


module.exports = val;

module.exports = {

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```