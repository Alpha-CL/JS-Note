# Performance optimization

## Problem

#### 性能优化

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 性能优化
 * 
 * 
 * 构建性能 + 传输性能 + 运行性能 
 */


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 构建性能
 * 
 * 
 */

描述: 指开发阶段的构建性能

目标: 降低从打包开始，到代码效果呈现所经过的时间

影响: 构建性能会影响开发效率，构建性能越高，开发过程中时间浪费的越少


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 传输性能
 * 
 * 
 */

描述: 指打包后的 JS代码，用户请求后 由服务器传输到浏览器经过的时间

优化思路: 

1) 总传输量:

   所需传输的 JS文件 内容加起来称为 总传输量，重复代码越少，总传输越少

2) 文件数量:

   当访问页面时，需要传输的 JS 文件数量越多，http 请求即越多，相应速度越慢

3) 浏览器缓存

   JS 文件会被 浏览器缓存，被缓存的文件不会再进行传输


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 运行性能
 * 
 * 
 */

描述: 指 JS代码 在浏览器端的运行速度，取决于 开发者如何书写 高性能代码


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## Resolve

#### 减少模块解析

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



chunk {         // 用于记录模块转换后的代码
    
    'moduleId': 'tranformedCode'
    './scr/index.js': 'xxxxxxx',
    ...
}
                    /\
                   /||\
                    ||
                  检查记录
       
入口 ----> 入口模块文件 -------> 已记录则结束 ---> 读取文件内容 --> AST( 抽象语法树 ) ---> 将依赖关系保存 ------------>>
                              未记录则继续                        语法分析        ( 保存至 dependencies 文件中 )        
                                                               树形结构遍历      ( 获取 require(); 中 )
                                                               获取所有依赖      ( 所对应的完整路径作为 moduleId )


>> 替换依赖函数 ----------------------------------------> 保存转换后的模块代码 ----------------------------> 入口
require('a'); =>  __webpack_require('./src/a.js');
                                                                          根据 dependencies 中的依赖关系
                                                                              递归加载所有依赖模块


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


    -------> 当前模块是否满足某个规则 -------> 读取规则中对应的 loaders
                    |                                |
                    | no ( empty-arr )               |
                    |                               \|/
                    |
                    + -------------------------> loaders arr
                                                     |
                                                     |
                                                    \|/
    
    + --------------------------------------------------------------- +        
    |                                                                 |     \
    |                code          code          code          code   | ---- \
    |   <-- loader1 <---- loader2 <---- loader3 <---- loader4 <----   | ---- /      source code
    |                                                                 |     /
    + --------------------------------------------------------------- +      


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 模块解析
 * 
 * 
 * 包含: 抽象语法树分析，依赖分析，模块语法替换
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 若不做模块分析
 * 
 * 
 * 则该模块经过 loaders 处理后，直接输出最终代码( 没有 抽象语法树分析，依赖分析，模块语法替换 )
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 哪些模块不需要解析
 * 
 * 
 * 该模块无其他依赖( 通常为已打包好的第三方模块 )
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 根据正则匹配，设置模块不解析
 * 
 * 
 * 设置后无法该模块无法 抽象语法树分析，依赖分析，模块语法替换
 */

module.exports = {

    module: {
    
        noParse: /jquery/
    }
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 优化 loader 性能

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 限制 loader 应用 范围
 * 
 * 
 * 对于某些库，避免使用已打包好的 loader
 */

// eg: babel-loader 可以转换 ES6 或更高版本的语法
//     但有部分库本身就是用低版本的语法书写的，不需要转换
//     使用 babel-loader 反而会浪费构建时间
//
//     lodash 是在 ES5 之前出现的库( 使用 ES3 语法 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


module.rule.exclude || module.rule.include

module.exports = {

    module: {
    
        rules: {
        
            {
                test: /\.js$/,
                exclude: "loadash",
                use: "babel-loader"
            }
        }
    }
};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


{
    test: /\.js$/,
    exclude: /lodash/,
    use: ["babel-loader"]
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 缓存 loader 的结果                // cache-loader
 * 
 * 
 * 基于: 若某个文件内容不变，结果相同的 loader 解析后，解析结果仍不改变
 * 
 * 则: 可以将 loader 的解析结果保存下来，便于后续解析直接使用
 */

npm install --save-dev cache-loader


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


module.exports = {
    module: {
        rules: [
            {
                test: /\.css$/,
                use: ["cache-loader?cacheDirectory=\./cache", "style-loader", "css-loader?modules"]
            },
            {
                test: /.less$/,
                use: ["cache-loader?cacheDirectory=\./cache", "style-loader", "css-loader?modules", "less-loader"]
            },
            {
                test: /\.(jpe?g)|(png)|(gif)$/,
                use: ["cache-loader?cacheDirectory=\./cache", "file-loader"],
            },
            {
                test: /\.js$/,
                use: ["cache-loader?cacheDirectory=\./cache", "babel-loader"]
            }
        ]
    },
};


//-------------------------------------------------------------------------------------------------------------------//


/**
 * loader.pitch
 * 
 * 
 * cache-loader 运行原理
 */
 
 
    {
        test: /demo/,
        use: ["loader-1", "loader-2", "loader-3"]
    }


    根据路径判断是否有缓存，若当前 loader 有缓存，则直接返回该 loader 缓存的源代码

            path              path              path
    start --------> loader1 --------> loader2 --------> loader3 ----------------> +
                    .pitch            .pitch            .pitch                    |
                       |                 |                 |                      |   
                       |                 |                 |                + ---------- +    
                       |                 |                 |                |            |
                       |                 |                 |                |   source   |
     + <-------------- + <-------------- + <-------------- +                |            |
     |                                                                      + ---------- +              
     |                                                                            |      
     |                                                                            |      
    end   <-------- loader1 <-------- loader2 <-------- loader3 <---------------- +
           source            source            source


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 为 loader 运行开启多线程             // thread-loader
 * 
 * 
 * thread-loader 会开启一个线程池( 默认线程数量根电脑配置有关 )
 * 
 * webpack 会把 添加在 "thread-loader" 后的 loader 放入线程池中运行，以提高效率
 * 
 * 但后续添加的 loader 无法:
 * 
 *      1) 无法使用 webpack api 生成文件
 * 
 *      1) 无法使用自定义的 plugin api
 * 
 *      1) 无法访问 webpack options
 */

// 开启和管理线程需要消耗时间，在小型项目中使用 "thread-loader" 反而会增加构建时间


npm install --save-dev thread-loader


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


module.exports = {
    module: {
        rules: [
            {
                test: /\.css$/,
                use: ["thread", "style-loader", "css-loader?modules"]
            },
            {
                test: /.less$/,
                use: ["thread", "style-loader", "css-loader?modules", "less-loader"]
            },
            {
                test: /\.(jpe?g)|(png)|(gif)$/,
                use: ["thread", "file-loader"],
            },
            {
                test: /\.js$/,
                use: ["thread", "babel-loader"]
            }
        ]
    },
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 热替换( HMR )

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Hot Module Replacement
 * 
 * 
 * 热替换并不能降低构建时间( 可能还会稍微增加 )，但可以降低代码改动后到效果呈现之间的时间
 */


    // webpack-dev-server 普通运行流程: 重新请求所有资源

    Modify-Code ------> Restart-Webpack -----> Browser-Re-Request -----> Browser-Render
        |                                        all-source                     |
        |                                        page-refresh                   |
        |                                                                       |
        |                                                                       |
        |                                                                       |
        + --------------------------- Monitor --------------------------------- +



    // webpack-dev-server 热替换运行流程: 重新仅请求改动的资源

    Modify-Code ------> Restart-Webpack -----> Browser-Re-Request -----> Browser-Render
        |                                        changed-source                 |
        |                                                                       |
        |                                                                       |
        |                                                                       |
        + --------------------------- Monitor --------------------------------- +


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 开启 热更新
 * 
 * 
 * 
 */


module.exports = {

    devServer: {
    
        hot: true
    },
    
    plugins: [
    
        new webpack.HotModuleReplacementPlugin()            // 目前版本已默认载入，仅开启 devServer 设置即可
    ]
};


// 在入口文件( index.js )中加入以下代码

if (module.hot) {               // 判断是否开启热更新

    module.hot.accept();        // 开启热更新
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


if (module.hot) {

    module.hot.accept();
}


module <= function( moduule, exports, __webpack_require__ ) {}

hot    <= 在 webpack.config.js 中设置 devServer.hot = true; 会将此属性作为参数传入

默认情况下，webpack-dev-server 无论是否开启热更新，当重新打包后，都会调用 location.reload( 刷新页面 )


但 运行了 module.hot.accept(), 将改变

module.hot.accept(); 作用是让 webpack-dev-server 通过 socket 管道，把服务器更新的内容发送到浏览器

然后，将结果交给插件 HotModuleReplacementPlugin();

插件 HotModuleReplacementPlugin(); 会重新生成并覆盖原始代码，然后将代码重新执行


//-------------------------------------------------------------------------------------------------------------------//


/**
 * css 热更新
 * 
 * 
 * css 热更新，需要使用 style-loader
 */


因 热替换发生时，HotModuleReplacementPlugin(); 只会简单的重新运行模块代码

因此 style-loader 的代码一运行，就会重新设置 style 元素中的样式

而 mini-css-extract-plugin，由于它生成文件是在 构建期间，则运行期间无法改动文件，则该插件在热更新中无效



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 分包

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 什么是分包
 * 
 * 
 */

讲一个整体的代码，拆分到不同的打包文件中


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 为什么要分包
 * 
 * 
 */

减少公共代码，降低总体积( 部分大型大地方库: juery ... )

充分利用浏览器缓存( 加载第三方库后，因文件不会更改，则无需重新加载，再次请求则可以直接调用缓存 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 何时分包
 * 
 * 
 */

多个 chunk 引入了公共模块

公共模块体积较大 或 减少变动


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 如何分包
 * 
 * 
 */

手动分包

自动分包


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 手动分包
 * 
 * 
 */


// 手动打包 - 过程

1) 开启 output.libray 暴露公共模块

2) 利用 webpack.DllPlugin(); 创建资源清单

3) 利用 webpack.DllReferencePlugin(); 使用资源清单


// 手动打包 - 注意事项

1) '资源清单' 不参与运行，可以不放到 打包目录中

2) 需要手动引入 公共 JS 打包文件，以及避免被删除( cleanPlugin 在打包时会清空目录 )

3) 不要对小型公共 JS 库 使用


// 手动打包 - 优点

1) 极大的提升自身模块的打包速度

2) 极大的缩小了自身文件体积

3) 有利于浏览器缓存第三方库的公共代码


// 手动打包 - 缺点

1) 使用较繁琐

2) 若第三方库中包含重复代码，则效果不太理想


//-------------------------------------------------------------------------------------------------------------------//


step - 1: 单独打包公共模块

          公共模块会被打包称为动态链接库( dll Dynamic Lik Library )，并生成资源清单


                + --------- +
                |           |
                |           | ====> dll/jquery.js
                |           |       暴露变量
    jquery ---> +  jq.pkg   |
                |           |
                |           | ====> dll/lodash.js
                |           |       暴露变量
                |           |
    lodash ---> +  ld.pkg   |
                |           | ====> manifest.json                                   // 生成资源清单
                |           |       ./node_modules/jquery:jquery, dll/jquery.js
                |           |       ./node_modules/lodash:lodash, dll/lodash.js
                |           |       ...
                + --------- +


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


为公共模块创建单独的配置文件

touch webpack.dll.config.js         // dll: dynamic link library( 动态链接库 )

echo 'const webpack = require("webpack"),
    path = require("path");

module.exports = {
    mode: "production",
    entry: {
        jquery: ["jquery"],
        lodash: ["lodash"]
    },
    output: {

        filename: "dll/[name].js",
        library: "[name]",                  // 每个 bundle 暴露的全局变量名
        libraryTarget: "var"                // 全局暴露变量的方式，默认: var
    },
    plugins: [
        new CleanWebpackPlugin({
        
            // 因 clean-plugin 打包时会清空 dist/ 目录，需设置匹配规则
            // 
            // *:  匹配任意字符，不包括 /
            // ?:  匹配任意单个字符，不包括 /
            // **: 匹配任意数量的字符，包括 /
            // {}: 匹配表达式
            // !:  不匹配指定字符
            
            cleanOnceBeforeBuildPatterns: ["**/*", "!dll", "!dist/"]
        }),
        new webpack.DllPlugin({

            path: path.resolve(__dirname, "dll", "[name].manifest.json"),           // 生成资源清单
            name: "[name]"                                                          // 源清单中暴露的全局变量名规则
        })
    ]
};' > webpack.dll.config.js


// 手动打包公共模块

"dll": "webpack --config webpack.dll.config.js"         // npm run dll



//-------------------------------------------------------------------------------------------------------------------//


step - 2: 根据入口模块正常打包

          打包时，若发现模块中使用了 '资源清单' 中描述的模块，则不会生成以下代码


    import $ from "jquery";
    import _ from "lodash";
    
    _.isArray($(".red"));



// 模拟内部原理

(function(modules){

    // ...
    
}({

    // index.js 打包结果并无变化
    
    "./src/index.js": function(module, exports, __webpacl_require__) {
    
        var $ = __webpack_require__("./node_modules/jquery/index.js"),
            _ = __webpack_require__("./node_modules/lodash/index.js");
            
        _.isArray($(".red"));
    },
    
    // 因 资源清单中 存在，则 jquery 的源码包 不会打包在这里
    
    "./node_modules/jquery/index.js": function(module, exports, __webpacl_require__) {
    
        module.exports = jquery;
    },
    
    
    // 因 资源清单中 存在，则 lodash 的源码包 不会打包在这里
    
    "./node_modules/lodash/index.js": function(module, exports, __webpacl_require__) {
    
        module.exports = lodash;
    }
}));


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 自动分包                 // 重点: 分包策略
 * 
 * 
 * 自动分包从更宏观的角度控制分包，一般不针对某个具体的包进行控制
 * 
 * 分包策略: webpack 会根据 分包策略 自动进行分包
 */

// webpack 内部使用 SplitChunksPlugin 进行分包
// 
// 之前的 CommonsChunkPlugin 也可以实现分包( 由于该库某部分不完善 )，至 webpack4 后，已被 SplitChunksPlugin 取代


//-------------------------------------------------------------------------------------------------------------------//


                + ---------- webpack ---------- +
                |                               |
                |   + ------------ +            |
                |   |              |            |       
    chunk1 ---> +   |              |  chunk1    | ====> bundle1.js
    commonCode  |   |              |            |
                |   | distribution |  chunk2    | ====> bundle2.js
                |   | strategy     |            |       
                |   |              |  chunk3    | ====> bundle_common.js
    chunk2 ---> +   |              |            |
    commonCode  |   |              |            |
                |   + ------------ +            |       
                |                               |       
                + ----------------------------- +


1) 分包策略: 重要，并且决定了如何分包

2) 分包时，开启了一个新的 chunk，对分离的模块进行打包

3) 打包结果中，公共的部分被提取出来形成了一个单独的文件，该文件属于 新chunk 的产物


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//







///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```







