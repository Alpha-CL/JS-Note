## Problem

#### 类名冲突

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 类名冲突
 * 
 * 
 */

过深的层级不利于编写、阅读、压缩、复用

过浅的类名容易导致类名冲突


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 如何解决类名冲突


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


/**
 * 命名约定
 * 
 * 
 * 提供一种命名的标准，解决 类名冲突
 */

BEM, OOCSS, AMCSS, SMACSS ...


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


/**
 * CSS in JS                    // 此方案在手机端 React Native 中大放异彩
 * 
 * 
 */

利用 js 对象 表示样式，然后直接应用到元素的 style 中，这样以来 css 变成了 一个一个的对象
( 利用 JS 的语言优势，规避重用，重名等问题 )

1) 通过一个函数翻互殴一个样式对象

2) 把公共样式提取到公共模版中返回

3) 应用 JS 的各种特性操作对象，比如: 混合、提取、拆分...

4) ...


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


/**
 * CSS Module
 * 
 * 
 */

利用 webpack 模块化编写方案，简单易用、不重名等


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 重复样式

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 重复样式
 * 
 * 
 * 重复样式不断出现在 css 代码中，增加了维护难度
 */

eg: 网站主色调: primary, info, wran, error, success ...

若网站已定义主色调( 并且已有部分颜色由主色调改变而来 )，一旦要做主色调调整，则会产生一个非常大的工程


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * CSS in JS                    // 此方案在手机端 React Native 中大放异彩
 * 
 * 
 * 由于放弃了选择选择器，很多写 css 的开发者并不是很适应
 */

利用 js 对象 表示样式，然后直接应用到元素的 style 中，这样以来 css 变成了 一个一个的对象
( 利用 JS 的语言优势，规避重用，重名等问题 )

1) 通过一个函数翻互殴一个样式对象

2) 把公共样式提取到公共模版中返回

3) 应用 JS 的各种特性操作对象，比如: 混合、提取、拆分...

4) ...


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


/**
 * 预编译器
 * 
 * 
 * 常见的 CSS预编译工具: less, sass             // 仅针对 CSS 的构建工具
 */

预编译器: CSS 进化版，支持变量，函数等高级语法，在书写时利用便捷的 预编译语法，生产时导出 符合 CSS 规范的代码


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### CSS 文件细分

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * CSS 文件细分
 * 
 * 
 */

大型项目中，CSS 也需要更细的拆分，有利于 CSS 代码的维护

在真是环境下，希望 CSS 文件越少越好，开发环境中，希望 CSS 文件分类越细越好


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 依靠构建工具，例如 webpack 等
 * 
 * 
 */

利用 loader 或 plugin 打包、合并、压缩 CSS 文件


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## Resolve

### 解决文件细分

#### css-loader

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * css-loader
 * 
 * 
 * 将 css 代码转换为 js 代码，以便 webpack 分析依赖和运行
 * 
 * 原理: 将 css 代码作为 字符串 导出
 */

1) 

2) 


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 简化版示例


.red {
    color: "#f40";
}


module.exports = `.red{
    color: "#f40";
}`


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


.red {
    color: "#f40";
    background: url('./bg.png');
}


const import = require('./bg.png');                 // 根据语法分析，利用 file-loader 返回 文件路径

module.exports = `.red{
    color: "#f40";
    background-url("${import1}");                   // 根据返回的 文件路径 填入
`;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### style-loader

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * style-loader
 * 
 * 
 * 由于 css-loader 仅将 css 代码转换为字符串导出，并未将css 代码添加到页面 style 元素中
 * 
 * style-loader 可以将 css-loader 转换后的代码做进一步处理，将 css-loader 导出的字符串加入到页面的 style 元素中
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 简化模拟原理

.red {
    color: "#f40";
}

module.exports = `.red{

    color: "#f40";
}`;


let style = module.exports,
    styleElem = document.createElement('style');

styleElem.innerHTML = style;

document.head.appendChild(styleElem);

module.exports = {};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### 解决类名冲突

#### BEM

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * BEM          // Block Element Modifier
 * 
 * 
 * 针对 CSS 类样式的一种命名方法
 */

block_elemnt_modifier               // 区域_组件_状态


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


block: 页面中的大区域，表示最顶级的划分

eg: 轮播图( banner ), 布局( layout ), 文章( article ) ...


element: 区域中的组成部分

eg: 轮播图中的横幅图片( banner_img ), 轮播图中的容器( banner_container ), 布局中的顶部( layout_header )

    文章中的标题( article_title ) ...


modifier: 可选，通常表示状态

eg: 处于展开状态的布局左边栏( layout_left_expand )，处于选中状态的轮播小圆点( banner_dot_selected ) ...


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 部分大型工程中，若使用 BEM 命名，可能会增加部分前缀，表示类名用途


l: layout           // 表示样式用于布局

c: component        // 表示样式为组件

u: util             // 表示样式为通用样式

j: javascript       // 表示样式无意义，仅为 js 使用


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### Css in JS

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Css in JS
 * 
 * 
 * 使用 JS 对象来描述样式，而不是 CSS 样式表        // 这种描述形式 根本不存在类名，所以不会有类名冲突
 * 
 * vue, react 都支持 css in js, 可以非常轻松的应用到界面
 */


eg:

const style = {
    backgroundColor: '#f40',
    color: '#fff',
    width: '520px',
    height: '1314p',
    margin: '0 auto'
};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// css in js 特点

1) 类名无冲突:

由于根本不存在类名，所以类名不会存在


2) 更加灵活:

可以充分利用 JS 语言灵活的特点，可以利用 函数，对象 及其他方式灵活处理


3) 应用面广:

只要支持 js 语言，就可以支持 css in js，因此，在一些用 JS 语言开发移动端应用的时候非常好用( 移动端可能并不支持 css )


4) 书写不便:

书写样式，特别是公共样式，处理起来不是很方便


5) 页面增加了大量冗余 css 代码:

在页面中处理 css in js 时，往往是将样式加入到元素的 style 属性中

会大量增加元素的内联样式，并且可能会有大量重复( 最终页面的代码不易阅读 )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```