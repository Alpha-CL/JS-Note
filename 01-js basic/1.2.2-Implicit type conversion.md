# Implicit type conversion

## ECMAScript 的运算符、{}解析、自动分号插入

#### 运算符执行顺序

<!-- table -->

| Operator | Description | 
| ---------------- | ----------------- |
| . [] ()	            | 字段访问、数组下标、函数调用以及表达式分组 |
| ++ — - + ~ ! delete new typeof void | 一元运算符、返回数据类型、对象创建、未定义值 |
| * / %	                | 乘法、除法、取模 |
| + - +	                | 加法、减法、字符串连接 |
| << >> >>>	            | 移位 |
| < <= > >= instanceof	| 小于、小于等于、大于、大于等于、instanceof |
| == != === !==	        | 等于、不等于、严格相等、非严格相等 |
| &	                    | 按位与 |
| ^	                    | 按位异或 |
| &&	                | 逻辑与 |
| ?:	                | 条件 |
| = oP=	                | 赋值、运算赋值 |
| ,	                    | 多重求值 |

#### {} 解析

> 当{}的前面有运算符号的时候，+，-，*，/,()等等，{}都会被解析成对象字面量
> 
> 当{}前面没有运算符时候但有;结尾的时候，或者浏览器的自动分号插入机制给{}后面插入分号(;)时候，此时{}都会被解析成代码块
> 
> 如果{}前面什么运算符都没有，{}后面也没有分号(;)结尾，Firefox会始终如一的解析为代码块，而chrome有细微的差别，chrome会解析为对象字面量

#### 自动补全分号( ; )

- 新行并入当前行将构成非法语句，自动插入分号。

- 在 continue, return, break,throw 后自动插入分号

- ++、-- 后缀表达式作为新行的开始，在行首自动插入分号

- 代码块的最后一个语句会自动插入分号

- 新行以 ( 、[、\、+ 、 - 、,、. % 和 * 开始都不会插入分号


***


## ECMAScript 的规范定义的抽象操作

- GetValue(v) : 引用规范类型

- Type(x) : 获取 x 的类型

- ToNumber(x) : 将x转换为 Number 类型

- ToString(x) : 将x转换为 String 类型

- SameValue(x,y) : 计算非数字类型 x, y 是否相同

- `ToPrimitive(x)` : 将x转换为原始值


#### ToPrimitive ES6


#### ToNumber

<!-- table -->

| input | result | 
| ---------------- | ----------------- |
| null	    |   +0 |
| undefined	|   NaN |
| number	|   不转换 |
| boolean	|   +0或1 |
| string	|   [参照§7.1.3.1](https://www.ecma-international.org/ecma-262/6.0/index.html#sec-tonumber-applied-to-the-string-type) |
| symbol	|   TypeError |
| object	|   ToNumber(ToPrimitive(input,Number)) |


1.把字符串转换成数字，不是简单地“去掉引号”

``` javascript


Number('123');//123
Number('');//0
Number(' 123 ');//123
Number('a123');//NaN



```

2.把symbol转换成数字，会直接抛出类型错误

3.把symbol转换成数字，会直接抛出类型错误


#### ToString


<!-- table -->

| input | result | 
| ---------------- | ----------------- |
| null	    | ‘null’ |
| undefined	| ‘undefined’ |
| number	| 参照§7.1.12.1 |
| boolean	| ‘true’或’false’ |
| string	| 不转换 |
| symbol	| TypeError |
| object	| ToString(ToPrimitive(input,String)) |


1.把数字转换成字符串，不是简单地“加上引号”

``` javascript


var a = Number.NaN;
String(a);//'NaN'
String(123);//'123'
String(+0);//'0'


```

2.把symbol转换成字符串，会直接抛出类型错误

3.把对象转换成字符串，会先进行ToPrimitive(input,String)，然后把得到的值进行转换


#### ToPrimitive

``` javascript

//syntax

ToPrimitive(input, PreferredType?): primitive;
 
/**
 * PreferredType?: 只接受 Number 或 String，作用是 设置 转换原值时 的 转换偏好
 *
 */


```

<!-- table -->

| inputType | result | 
| --------- | ------ |
| Null	    | 不转换，直接返回 |
| Undefined	| 不转换，直接返回 |
| Number	| 不转换，直接返回 |
| Boolean	| 不转换，直接返回 |
| String	| 不转换，直接返回 |
| Symbol	| 不转换，直接返回 |
| Object	| 按照下列步骤进行转换 |


1. 确保 input 是一个 JavaScript 的合法值

2. 如果 input 不是一个 Object 类 型的值返回 input 本身，否则继续

3. 如果 PreferredType 没有传，则令 hint 为“default”，跳到 `步骤6`

4. 如果 PreferredType 是字符串，则令 hint 为“string”，跳到 `步骤6`

5. 如果 PreferredType 是数字，则令 hint 为 “number”

6. 令 exoticToPrim 为 GetMethod(input, @@toPrimitive) 返回值，其中@@toPrimitive是一个用于将对象转成原始值的方法

7. 如果exoticToPrim为undefined，继续 `步骤8`，否则跳到 `步骤10`

8. 如果hint为“default”则将其改为“number”

9. 返回OrdinaryToPrimitive(input, hint)的值，结束

10. 令 result 为Call(exoticToPrim, input, « hint »)的返回值

11. 如果 result 的类型不是 Object，则返回 result，结束流程，否则抛出 TypeError 异常



#### typeof 

> 可以返回这些基本类型中的一种

``` javascript

//syntax

typeof input: string;
 

```

* 原始数据类型( primitives ): 不可改变的原始值

    - string

    - number

    - boolean
    
    -
    
* 复杂数据类型: 可以改变数据值的地址指向

    - object
    
        - Date
        
        - Array
        
        - null: 早期用于`代替空对象`，属于历史遗留问题
        
        - 
    
    - function
    
    -

* 其他数据类型

    - undefined
    
    - symbol
    
    
``` javascript


typeof(typeof(typeof(a)));          //string

typeof(typeof(undefined);           //undefined


```

    
    
``` javascript


typeof "John"              // Returns "string"
typeof 3.14                // Returns "number"
typeof true                // Returns "boolean"
typeof false               // Returns "boolean"
typeof x                   // Returns "undefined" (if x has no value)
typeof null                // Returns "null"


```

## 类型转换

### 隐式类型转换

#### isNaN(); -> Number();

``` javascript

//syntax

isNaN(value); -> Number(value): result; result ?== NaN => Boolean(true / false);


```

__++ / -- && +/-(一元正负)__ -> Number();

++ num; num --;

> 无论 value 是否被隐式转换为 Number 类型的值
> 
> 其类型都会被转换为 Number

``` javascript

//syntax

var key = value;

key ++;


//在 ++/-- 运算之前，先隐式转换为 Number 类型(无论 value 是否转换成功，类型都会转换为 Number)

if (++ / --) {

    var key = value; -> Number(value): result;
    
    if (typeof key == number || typeof key !== number) {
    
        typeof key; => Number
    }
} 

result ++;


```

\+ num; - num;

> 无论 value 是否被隐式转换为 Number 类型的值
> 
> 其类型都会被转换为 Number

``` javascript

var key = (+ / -)value;

// 在 正负 value 之前，先隐

if ((+ / -) value) {

    (+ / -) value -> Number(value): result;
    
    if (typeof key == number || typeof key !== number) {
    
        typeof key; => Number
    }
}

(+ / -) result;

result (+ / -);

```


__+( 一元相加运算符 )__ -> Number();

> 一元运算符“+”是用来把目标转化成数字类型的

- 在加法的过程中，首先把等号左右两边进行了求原值ToPrimitive()操作，

- 然后如果两个原值只要有一个是String类型，就把两个原值都进行转化字符串ToString()操作，进行字符串拼接；

- 否则把两个原值都进行转化数字ToNumber()操作，进行数字相加



``` javascript


new(value?: any) + NaN: NaN;

-Infinity + -Infinity = -Infinity;

Infinity + -Infinity = NaN;

+0 + +0 = +0;

-0 + -0 = +0;

-0 + -0 = -0;


```

``` javascript


var result = key1 + key2;

// 如果多个变量 相加，其中有一个变量类型是 string，则会把其他的变量隐式转换为 string 后相加或相连

if (typeof key1 == string || typeof key2 == string ...) {

    (key1 / key2) -> String(key1 / key2): result;

}

reult + (key1 / key2);


```

__-( 一元减法运算符 )__


- 如果是两个数字，则直接相减得出结果

- 如果有一个不是数字，会调用 ToNumber 方法按照规则转化成数字类型，然后进行相减


``` javascript


new(value?: any) - NaN: NaN;

Infinity - Infinity = NaN;

-Infinity - -Infinity = NaN;

Infinity - -Infinity = -Infinity;

+0 - -0 = +0;

-0 - -0 = +0;

+0 - -0 = +0;


```

, -, \*, /, %


__&$, ||, !__

> 隐式类型转换 statements 为 Boolean(true / false)，
>
> 仅用于语句判断，并不改变语句或结果的类型

``` javascript

statement1 (&$, ||, !) statement2 -> Boolean( statement ): result;


```


#### 无规则

``` javascript


undefined > 0;          //false
undefined < 0;          //false
undefined == 0;         //false

null > 0;               //false
null < 0;               //false
null == 0;              //false

undefined == false;     //true

NaN == NaN;             //false


```

#### 不发生类型转换

`===` `!==`


### 显示类型转换

#### Number();

> 转换为`数字`

``` javascript

//syntax

new(value?: any): Number;

(value?: any): number;


```

``` javascript

Number('6');                //6
Number('-6');               //-6

Number('a');                //NaN
Number('666aaa');           //NaN

Number(ture);               //1
Number(false);              //0

Number(null);               //0

Number(undefined);          //NaN


```

#### parseInt();

转换为`整型`

> 只关注 数字、字符串数字、小数，其他类转换为 NaN
> 
> para@2: 转换 radix? 进制数
> 
> 从数字位开始截取至非数字位之前的数字并返回

``` javascript

//syntax

parseInt(s: string, radix?: number): number;


```

``` javascript


parseInt(22);                   //22
parseInt("2.3355");             //2
parseInt(2431.31431);           //2431

parseInt('123px');              //123


```


#### parseFloat(); 


``` javascript

//syntax

parseFloat(string: string): number;
 

```


#### String();

``` javascript

//syntax

new(value?: any): String;
(value?: any): string;


```

#### Boolean();


``` javascript

//syntax

new(value?: any): Boolean;
(value?: any): boolean;
 

```

#### toString

> undefined null 不能使用 toString，会报错

``` javascript

//syntax

toString(radix?: number): string;
 

```

``` javascript


//2 --> 10 --> 16

var num = 10000;

var test = parseInt(num);

console.log(test.toString(16));                 //10


```



