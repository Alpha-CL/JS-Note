


* 原型

    * 两者均是原型

        * __proto__
    
        * prototype
        
        * 
    
    * 作用
    
        * 共享数据，节省内存空间
        
        * 
        
    * 区别

        * 实际对象
        
            * __proto__: 原型
            
            * 浏览器使用( 不是标准属性 )
            
            * 
        
        * 构造函数
        
            * prototype: 原型
            
            * 程序猿使用( 标准属性 )
            
            * 
        
    * console.log(per.__proto__ == Person.prototype); ==> true
    
        ( IE8 中为 false )
    
        * __proto__
    
            * IE8( 不支持 )
        
                * undefined
            
                * 
                
            * 火狐、谷歌( 支持 )   
            
                * 
                
        * prototype
        
            *          
    
    * console.log(per.__proto__.constructor == Person.prototype.constructor) == true
    
        * 
    


* 构造函数、实例对象、原型对象

    * function Person(name, age) {
    
        * this.name = name;
        
        * this.age = age;

    * }

    * 
    
    * 实例化构造函数
    
    * var per = new Person('alpha', 18);
    
    * 
    
    * 通过 prototype 增加方法
    
        * 不会增加到 per( 实例对象 ) 中，只会在构造函数的 prototype 中添加此方法
        
        * 但是 per 可以调用此方法，因为 per 中的 __proto__ 和 Person 中 prototype 指向相同的 栈( 共享数据，节省内存空间 )
        
            * 也可以称为: 构造函数中的 prototype 共享给了 事例对象的 __proto__
            
            * 所以 事例对象 可以访问 构造函数中的 prototype 存储的 属性 或 方法 等 
            
            * 仅单方面共享，事例函数中的 属性 和 方法 并不会 共享给 构造函数
            
            *  
    
    * per.prototype.eat = function eat() {
        
        * console.log('hello world');

    * };

    * 
    
    * console.dir(per);
    
    * console.dir(Person);
    
    * 

        * 构造函数: Person();
        
            * prototype
            
            * 
        
        * 实例对象: per;
        
            * name 属性
            
            * age 属性
            
            * __proto__ 属性
            
            * 
        
        * 原型对象: Person.prototype;
        
            * constructor 构造器
            
            * eat 方法
            
            * 
            
    * 构造函数可以创建实例化对象
    
    * 构造函数中有一个属性 prototype，是构造函数的 原型对象
    
    * 构造函数的原型对象( prototype ) 中有一个 constructor 构造起，这个构造器指向自己所在的原型对象( prototype )所在的构造函数( Person )
    
    * 实例对象的原型对象( __proto__ ) 指向该构造函数的原型对象
    
        * 如果某个对象是 __proto__ 大多数情况下，当前是 实例对象
    
    * 构造函数是的原型对象( prototype ) 中的方法是可以被实际对象直接访问的
    
    * 

















